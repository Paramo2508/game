// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.4
// source: proto/galaxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "galaxy";

export enum EventType {
  EvUnused = 0,
  EvNewFood = 1,
  EvNewPlayer = 2,
  EvPlayerMove = 3,
  EvPlayerGrow = 4,
  EvDestroyFood = 5,
  EvDestroyPlayer = 6,
  EvJoin = 7,
  EvPause = 8,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "EvUnused":
      return EventType.EvUnused;
    case 1:
    case "EvNewFood":
      return EventType.EvNewFood;
    case 2:
    case "EvNewPlayer":
      return EventType.EvNewPlayer;
    case 3:
    case "EvPlayerMove":
      return EventType.EvPlayerMove;
    case 4:
    case "EvPlayerGrow":
      return EventType.EvPlayerGrow;
    case 5:
    case "EvDestroyFood":
      return EventType.EvDestroyFood;
    case 6:
    case "EvDestroyPlayer":
      return EventType.EvDestroyPlayer;
    case 7:
    case "EvJoin":
      return EventType.EvJoin;
    case 8:
    case "EvPause":
      return EventType.EvPause;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.EvUnused:
      return "EvUnused";
    case EventType.EvNewFood:
      return "EvNewFood";
    case EventType.EvNewPlayer:
      return "EvNewPlayer";
    case EventType.EvPlayerMove:
      return "EvPlayerMove";
    case EventType.EvPlayerGrow:
      return "EvPlayerGrow";
    case EventType.EvDestroyFood:
      return "EvDestroyFood";
    case EventType.EvDestroyPlayer:
      return "EvDestroyPlayer";
    case EventType.EvJoin:
      return "EvJoin";
    case EventType.EvPause:
      return "EvPause";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OperationType {
  OpUnused = 0,
  OpJoin = 1,
  OpLeave = 2,
  OpMove = 3,
  OpEatPlayer = 4,
  OpEatFood = 5,
  OpPause = 6,
  UNRECOGNIZED = -1,
}

export function operationTypeFromJSON(object: any): OperationType {
  switch (object) {
    case 0:
    case "OpUnused":
      return OperationType.OpUnused;
    case 1:
    case "OpJoin":
      return OperationType.OpJoin;
    case 2:
    case "OpLeave":
      return OperationType.OpLeave;
    case 3:
    case "OpMove":
      return OperationType.OpMove;
    case 4:
    case "OpEatPlayer":
      return OperationType.OpEatPlayer;
    case 5:
    case "OpEatFood":
      return OperationType.OpEatFood;
    case 6:
    case "OpPause":
      return OperationType.OpPause;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationType.UNRECOGNIZED;
  }
}

export function operationTypeToJSON(object: OperationType): string {
  switch (object) {
    case OperationType.OpUnused:
      return "OpUnused";
    case OperationType.OpJoin:
      return "OpJoin";
    case OperationType.OpLeave:
      return "OpLeave";
    case OperationType.OpMove:
      return "OpMove";
    case OperationType.OpEatPlayer:
      return "OpEatPlayer";
    case OperationType.OpEatFood:
      return "OpEatFood";
    case OperationType.OpPause:
      return "OpPause";
    case OperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Vector2D {
  X: number;
  Y: number;
}

export interface Event {
  eventType: EventType;
  newPlayerEvent?: NewPlayerEvent | undefined;
  newFoodEvent?: NewFoodEvent | undefined;
  playerMoveEvent?: PlayerMoveEvent | undefined;
  playerGrowEvent?: PlayerGrowEvent | undefined;
  destroyFoodEvent?: DestroyFoodEvent | undefined;
  destroyPlayerEvent?: DestroyPlayerEvent | undefined;
  joinEvent?: JoinEvent | undefined;
  pauseEvent?: PauseEvent | undefined;
}

export interface NewPlayerEvent {
  playerID: Uint8Array;
  position: Vector2D | undefined;
  radius: number;
  color: number;
  skin: string;
  username: string;
}

export interface JoinEvent {
  playerID: Uint8Array;
  position: Vector2D | undefined;
  radius: number;
  color: number;
  skin: string;
}

export interface Food {
  position: Vector2D | undefined;
  color: number;
}

export interface NewFoodEvent {
  food: Food[];
}

export interface PlayerMoveEvent {
  playerID: Uint8Array;
  position: Vector2D | undefined;
}

export interface PlayerGrowEvent {
  playerID: Uint8Array;
  radius: number;
}

export interface DestroyFoodEvent {
  position: Vector2D | undefined;
}

export interface DestroyPlayerEvent {
  playerID: Uint8Array;
}

export interface PauseEvent {
}

export interface Operation {
  operationType: OperationType;
  joinOperation?: JoinOperation | undefined;
  leaveOperation?: LeaveOperation | undefined;
  moveOperation?: MoveOperation | undefined;
  eatPlayerOperation?: EatPlayerOperation | undefined;
  eatFoodOperation?: EatFoodOperation | undefined;
  pauseOperation?: PauseOperation | undefined;
}

export interface JoinOperation {
  playerID: Uint8Array;
  username: string;
  color: number;
  skin: string;
  gameID: number;
}

export interface LeaveOperation {
}

export interface MoveOperation {
  position: Vector2D | undefined;
}

export interface EatPlayerOperation {
  playerEaten: Uint8Array;
  newRadius: number;
}

export interface EatFoodOperation {
  foodPosition: Vector2D | undefined;
  newRadius: number;
}

export interface PauseOperation {
}

function createBaseVector2D(): Vector2D {
  return { X: 0, Y: 0 };
}

export const Vector2D: MessageFns<Vector2D> = {
  encode(message: Vector2D, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.X !== 0) {
      writer.uint32(8).uint32(message.X);
    }
    if (message.Y !== 0) {
      writer.uint32(16).uint32(message.Y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vector2D {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector2D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.X = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.Y = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector2D {
    return {
      X: isSet(object.X) ? globalThis.Number(object.X) : 0,
      Y: isSet(object.Y) ? globalThis.Number(object.Y) : 0,
    };
  },

  toJSON(message: Vector2D): unknown {
    const obj: any = {};
    if (message.X !== 0) {
      obj.X = Math.round(message.X);
    }
    if (message.Y !== 0) {
      obj.Y = Math.round(message.Y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector2D>, I>>(base?: I): Vector2D {
    return Vector2D.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector2D>, I>>(object: I): Vector2D {
    const message = createBaseVector2D();
    message.X = object.X ?? 0;
    message.Y = object.Y ?? 0;
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    eventType: 0,
    newPlayerEvent: undefined,
    newFoodEvent: undefined,
    playerMoveEvent: undefined,
    playerGrowEvent: undefined,
    destroyFoodEvent: undefined,
    destroyPlayerEvent: undefined,
    joinEvent: undefined,
    pauseEvent: undefined,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.newPlayerEvent !== undefined) {
      NewPlayerEvent.encode(message.newPlayerEvent, writer.uint32(18).fork()).join();
    }
    if (message.newFoodEvent !== undefined) {
      NewFoodEvent.encode(message.newFoodEvent, writer.uint32(26).fork()).join();
    }
    if (message.playerMoveEvent !== undefined) {
      PlayerMoveEvent.encode(message.playerMoveEvent, writer.uint32(34).fork()).join();
    }
    if (message.playerGrowEvent !== undefined) {
      PlayerGrowEvent.encode(message.playerGrowEvent, writer.uint32(42).fork()).join();
    }
    if (message.destroyFoodEvent !== undefined) {
      DestroyFoodEvent.encode(message.destroyFoodEvent, writer.uint32(50).fork()).join();
    }
    if (message.destroyPlayerEvent !== undefined) {
      DestroyPlayerEvent.encode(message.destroyPlayerEvent, writer.uint32(58).fork()).join();
    }
    if (message.joinEvent !== undefined) {
      JoinEvent.encode(message.joinEvent, writer.uint32(66).fork()).join();
    }
    if (message.pauseEvent !== undefined) {
      PauseEvent.encode(message.pauseEvent, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPlayerEvent = NewPlayerEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newFoodEvent = NewFoodEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.playerMoveEvent = PlayerMoveEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.playerGrowEvent = PlayerGrowEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destroyFoodEvent = DestroyFoodEvent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.destroyPlayerEvent = DestroyPlayerEvent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.joinEvent = JoinEvent.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pauseEvent = PauseEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      eventType: isSet(object.eventType) ? eventTypeFromJSON(object.eventType) : 0,
      newPlayerEvent: isSet(object.newPlayerEvent) ? NewPlayerEvent.fromJSON(object.newPlayerEvent) : undefined,
      newFoodEvent: isSet(object.newFoodEvent) ? NewFoodEvent.fromJSON(object.newFoodEvent) : undefined,
      playerMoveEvent: isSet(object.playerMoveEvent) ? PlayerMoveEvent.fromJSON(object.playerMoveEvent) : undefined,
      playerGrowEvent: isSet(object.playerGrowEvent) ? PlayerGrowEvent.fromJSON(object.playerGrowEvent) : undefined,
      destroyFoodEvent: isSet(object.destroyFoodEvent) ? DestroyFoodEvent.fromJSON(object.destroyFoodEvent) : undefined,
      destroyPlayerEvent: isSet(object.destroyPlayerEvent)
        ? DestroyPlayerEvent.fromJSON(object.destroyPlayerEvent)
        : undefined,
      joinEvent: isSet(object.joinEvent) ? JoinEvent.fromJSON(object.joinEvent) : undefined,
      pauseEvent: isSet(object.pauseEvent) ? PauseEvent.fromJSON(object.pauseEvent) : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = eventTypeToJSON(message.eventType);
    }
    if (message.newPlayerEvent !== undefined) {
      obj.newPlayerEvent = NewPlayerEvent.toJSON(message.newPlayerEvent);
    }
    if (message.newFoodEvent !== undefined) {
      obj.newFoodEvent = NewFoodEvent.toJSON(message.newFoodEvent);
    }
    if (message.playerMoveEvent !== undefined) {
      obj.playerMoveEvent = PlayerMoveEvent.toJSON(message.playerMoveEvent);
    }
    if (message.playerGrowEvent !== undefined) {
      obj.playerGrowEvent = PlayerGrowEvent.toJSON(message.playerGrowEvent);
    }
    if (message.destroyFoodEvent !== undefined) {
      obj.destroyFoodEvent = DestroyFoodEvent.toJSON(message.destroyFoodEvent);
    }
    if (message.destroyPlayerEvent !== undefined) {
      obj.destroyPlayerEvent = DestroyPlayerEvent.toJSON(message.destroyPlayerEvent);
    }
    if (message.joinEvent !== undefined) {
      obj.joinEvent = JoinEvent.toJSON(message.joinEvent);
    }
    if (message.pauseEvent !== undefined) {
      obj.pauseEvent = PauseEvent.toJSON(message.pauseEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.eventType = object.eventType ?? 0;
    message.newPlayerEvent = (object.newPlayerEvent !== undefined && object.newPlayerEvent !== null)
      ? NewPlayerEvent.fromPartial(object.newPlayerEvent)
      : undefined;
    message.newFoodEvent = (object.newFoodEvent !== undefined && object.newFoodEvent !== null)
      ? NewFoodEvent.fromPartial(object.newFoodEvent)
      : undefined;
    message.playerMoveEvent = (object.playerMoveEvent !== undefined && object.playerMoveEvent !== null)
      ? PlayerMoveEvent.fromPartial(object.playerMoveEvent)
      : undefined;
    message.playerGrowEvent = (object.playerGrowEvent !== undefined && object.playerGrowEvent !== null)
      ? PlayerGrowEvent.fromPartial(object.playerGrowEvent)
      : undefined;
    message.destroyFoodEvent = (object.destroyFoodEvent !== undefined && object.destroyFoodEvent !== null)
      ? DestroyFoodEvent.fromPartial(object.destroyFoodEvent)
      : undefined;
    message.destroyPlayerEvent = (object.destroyPlayerEvent !== undefined && object.destroyPlayerEvent !== null)
      ? DestroyPlayerEvent.fromPartial(object.destroyPlayerEvent)
      : undefined;
    message.joinEvent = (object.joinEvent !== undefined && object.joinEvent !== null)
      ? JoinEvent.fromPartial(object.joinEvent)
      : undefined;
    message.pauseEvent = (object.pauseEvent !== undefined && object.pauseEvent !== null)
      ? PauseEvent.fromPartial(object.pauseEvent)
      : undefined;
    return message;
  },
};

function createBaseNewPlayerEvent(): NewPlayerEvent {
  return { playerID: new Uint8Array(0), position: undefined, radius: 0, color: 0, skin: "", username: "" };
}

export const NewPlayerEvent: MessageFns<NewPlayerEvent> = {
  encode(message: NewPlayerEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.radius !== 0) {
      writer.uint32(24).uint32(message.radius);
    }
    if (message.color !== 0) {
      writer.uint32(32).uint32(message.color);
    }
    if (message.skin !== "") {
      writer.uint32(42).string(message.skin);
    }
    if (message.username !== "") {
      writer.uint32(50).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewPlayerEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewPlayerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.radius = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.skin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewPlayerEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      skin: isSet(object.skin) ? globalThis.String(object.skin) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: NewPlayerEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.skin !== "") {
      obj.skin = message.skin;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewPlayerEvent>, I>>(base?: I): NewPlayerEvent {
    return NewPlayerEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewPlayerEvent>, I>>(object: I): NewPlayerEvent {
    const message = createBaseNewPlayerEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    message.radius = object.radius ?? 0;
    message.color = object.color ?? 0;
    message.skin = object.skin ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseJoinEvent(): JoinEvent {
  return { playerID: new Uint8Array(0), position: undefined, radius: 0, color: 0, skin: "" };
}

export const JoinEvent: MessageFns<JoinEvent> = {
  encode(message: JoinEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.radius !== 0) {
      writer.uint32(24).uint32(message.radius);
    }
    if (message.color !== 0) {
      writer.uint32(32).uint32(message.color);
    }
    if (message.skin !== "") {
      writer.uint32(42).string(message.skin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.radius = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.skin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      skin: isSet(object.skin) ? globalThis.String(object.skin) : "",
    };
  },

  toJSON(message: JoinEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.skin !== "") {
      obj.skin = message.skin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinEvent>, I>>(base?: I): JoinEvent {
    return JoinEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinEvent>, I>>(object: I): JoinEvent {
    const message = createBaseJoinEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    message.radius = object.radius ?? 0;
    message.color = object.color ?? 0;
    message.skin = object.skin ?? "";
    return message;
  },
};

function createBaseFood(): Food {
  return { position: undefined, color: 0 };
}

export const Food: MessageFns<Food> = {
  encode(message: Food, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.color !== 0) {
      writer.uint32(16).uint32(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Food {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFood();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Food {
    return {
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
    };
  },

  toJSON(message: Food): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    if (message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Food>, I>>(base?: I): Food {
    return Food.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Food>, I>>(object: I): Food {
    const message = createBaseFood();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    message.color = object.color ?? 0;
    return message;
  },
};

function createBaseNewFoodEvent(): NewFoodEvent {
  return { food: [] };
}

export const NewFoodEvent: MessageFns<NewFoodEvent> = {
  encode(message: NewFoodEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.food) {
      Food.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewFoodEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewFoodEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.food.push(Food.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewFoodEvent {
    return { food: globalThis.Array.isArray(object?.food) ? object.food.map((e: any) => Food.fromJSON(e)) : [] };
  },

  toJSON(message: NewFoodEvent): unknown {
    const obj: any = {};
    if (message.food?.length) {
      obj.food = message.food.map((e) => Food.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewFoodEvent>, I>>(base?: I): NewFoodEvent {
    return NewFoodEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewFoodEvent>, I>>(object: I): NewFoodEvent {
    const message = createBaseNewFoodEvent();
    message.food = object.food?.map((e) => Food.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayerMoveEvent(): PlayerMoveEvent {
  return { playerID: new Uint8Array(0), position: undefined };
}

export const PlayerMoveEvent: MessageFns<PlayerMoveEvent> = {
  encode(message: PlayerMoveEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerMoveEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerMoveEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerMoveEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: PlayerMoveEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerMoveEvent>, I>>(base?: I): PlayerMoveEvent {
    return PlayerMoveEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerMoveEvent>, I>>(object: I): PlayerMoveEvent {
    const message = createBasePlayerMoveEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBasePlayerGrowEvent(): PlayerGrowEvent {
  return { playerID: new Uint8Array(0), radius: 0 };
}

export const PlayerGrowEvent: MessageFns<PlayerGrowEvent> = {
  encode(message: PlayerGrowEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.radius !== 0) {
      writer.uint32(16).uint32(message.radius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerGrowEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerGrowEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.radius = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerGrowEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
    };
  },

  toJSON(message: PlayerGrowEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerGrowEvent>, I>>(base?: I): PlayerGrowEvent {
    return PlayerGrowEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerGrowEvent>, I>>(object: I): PlayerGrowEvent {
    const message = createBasePlayerGrowEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.radius = object.radius ?? 0;
    return message;
  },
};

function createBaseDestroyFoodEvent(): DestroyFoodEvent {
  return { position: undefined };
}

export const DestroyFoodEvent: MessageFns<DestroyFoodEvent> = {
  encode(message: DestroyFoodEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyFoodEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyFoodEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyFoodEvent {
    return { position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined };
  },

  toJSON(message: DestroyFoodEvent): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyFoodEvent>, I>>(base?: I): DestroyFoodEvent {
    return DestroyFoodEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyFoodEvent>, I>>(object: I): DestroyFoodEvent {
    const message = createBaseDestroyFoodEvent();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseDestroyPlayerEvent(): DestroyPlayerEvent {
  return { playerID: new Uint8Array(0) };
}

export const DestroyPlayerEvent: MessageFns<DestroyPlayerEvent> = {
  encode(message: DestroyPlayerEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyPlayerEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyPlayerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyPlayerEvent {
    return { playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0) };
  },

  toJSON(message: DestroyPlayerEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyPlayerEvent>, I>>(base?: I): DestroyPlayerEvent {
    return DestroyPlayerEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyPlayerEvent>, I>>(object: I): DestroyPlayerEvent {
    const message = createBaseDestroyPlayerEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    return message;
  },
};

function createBasePauseEvent(): PauseEvent {
  return {};
}

export const PauseEvent: MessageFns<PauseEvent> = {
  encode(_: PauseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PauseEvent {
    return {};
  },

  toJSON(_: PauseEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PauseEvent>, I>>(base?: I): PauseEvent {
    return PauseEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PauseEvent>, I>>(_: I): PauseEvent {
    const message = createBasePauseEvent();
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    operationType: 0,
    joinOperation: undefined,
    leaveOperation: undefined,
    moveOperation: undefined,
    eatPlayerOperation: undefined,
    eatFoodOperation: undefined,
    pauseOperation: undefined,
  };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationType !== 0) {
      writer.uint32(16).int32(message.operationType);
    }
    if (message.joinOperation !== undefined) {
      JoinOperation.encode(message.joinOperation, writer.uint32(26).fork()).join();
    }
    if (message.leaveOperation !== undefined) {
      LeaveOperation.encode(message.leaveOperation, writer.uint32(34).fork()).join();
    }
    if (message.moveOperation !== undefined) {
      MoveOperation.encode(message.moveOperation, writer.uint32(42).fork()).join();
    }
    if (message.eatPlayerOperation !== undefined) {
      EatPlayerOperation.encode(message.eatPlayerOperation, writer.uint32(50).fork()).join();
    }
    if (message.eatFoodOperation !== undefined) {
      EatFoodOperation.encode(message.eatFoodOperation, writer.uint32(58).fork()).join();
    }
    if (message.pauseOperation !== undefined) {
      PauseOperation.encode(message.pauseOperation, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.joinOperation = JoinOperation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.leaveOperation = LeaveOperation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.moveOperation = MoveOperation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eatPlayerOperation = EatPlayerOperation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eatFoodOperation = EatFoodOperation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pauseOperation = PauseOperation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      operationType: isSet(object.operationType) ? operationTypeFromJSON(object.operationType) : 0,
      joinOperation: isSet(object.joinOperation) ? JoinOperation.fromJSON(object.joinOperation) : undefined,
      leaveOperation: isSet(object.leaveOperation) ? LeaveOperation.fromJSON(object.leaveOperation) : undefined,
      moveOperation: isSet(object.moveOperation) ? MoveOperation.fromJSON(object.moveOperation) : undefined,
      eatPlayerOperation: isSet(object.eatPlayerOperation)
        ? EatPlayerOperation.fromJSON(object.eatPlayerOperation)
        : undefined,
      eatFoodOperation: isSet(object.eatFoodOperation) ? EatFoodOperation.fromJSON(object.eatFoodOperation) : undefined,
      pauseOperation: isSet(object.pauseOperation) ? PauseOperation.fromJSON(object.pauseOperation) : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.operationType !== 0) {
      obj.operationType = operationTypeToJSON(message.operationType);
    }
    if (message.joinOperation !== undefined) {
      obj.joinOperation = JoinOperation.toJSON(message.joinOperation);
    }
    if (message.leaveOperation !== undefined) {
      obj.leaveOperation = LeaveOperation.toJSON(message.leaveOperation);
    }
    if (message.moveOperation !== undefined) {
      obj.moveOperation = MoveOperation.toJSON(message.moveOperation);
    }
    if (message.eatPlayerOperation !== undefined) {
      obj.eatPlayerOperation = EatPlayerOperation.toJSON(message.eatPlayerOperation);
    }
    if (message.eatFoodOperation !== undefined) {
      obj.eatFoodOperation = EatFoodOperation.toJSON(message.eatFoodOperation);
    }
    if (message.pauseOperation !== undefined) {
      obj.pauseOperation = PauseOperation.toJSON(message.pauseOperation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(object: I): Operation {
    const message = createBaseOperation();
    message.operationType = object.operationType ?? 0;
    message.joinOperation = (object.joinOperation !== undefined && object.joinOperation !== null)
      ? JoinOperation.fromPartial(object.joinOperation)
      : undefined;
    message.leaveOperation = (object.leaveOperation !== undefined && object.leaveOperation !== null)
      ? LeaveOperation.fromPartial(object.leaveOperation)
      : undefined;
    message.moveOperation = (object.moveOperation !== undefined && object.moveOperation !== null)
      ? MoveOperation.fromPartial(object.moveOperation)
      : undefined;
    message.eatPlayerOperation = (object.eatPlayerOperation !== undefined && object.eatPlayerOperation !== null)
      ? EatPlayerOperation.fromPartial(object.eatPlayerOperation)
      : undefined;
    message.eatFoodOperation = (object.eatFoodOperation !== undefined && object.eatFoodOperation !== null)
      ? EatFoodOperation.fromPartial(object.eatFoodOperation)
      : undefined;
    message.pauseOperation = (object.pauseOperation !== undefined && object.pauseOperation !== null)
      ? PauseOperation.fromPartial(object.pauseOperation)
      : undefined;
    return message;
  },
};

function createBaseJoinOperation(): JoinOperation {
  return { playerID: new Uint8Array(0), username: "", color: 0, skin: "", gameID: 0 };
}

export const JoinOperation: MessageFns<JoinOperation> = {
  encode(message: JoinOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.color !== 0) {
      writer.uint32(24).uint32(message.color);
    }
    if (message.skin !== "") {
      writer.uint32(34).string(message.skin);
    }
    if (message.gameID !== 0) {
      writer.uint32(40).uint32(message.gameID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.skin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gameID = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinOperation {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
      skin: isSet(object.skin) ? globalThis.String(object.skin) : "",
      gameID: isSet(object.gameID) ? globalThis.Number(object.gameID) : 0,
    };
  },

  toJSON(message: JoinOperation): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    if (message.skin !== "") {
      obj.skin = message.skin;
    }
    if (message.gameID !== 0) {
      obj.gameID = Math.round(message.gameID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinOperation>, I>>(base?: I): JoinOperation {
    return JoinOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinOperation>, I>>(object: I): JoinOperation {
    const message = createBaseJoinOperation();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.username = object.username ?? "";
    message.color = object.color ?? 0;
    message.skin = object.skin ?? "";
    message.gameID = object.gameID ?? 0;
    return message;
  },
};

function createBaseLeaveOperation(): LeaveOperation {
  return {};
}

export const LeaveOperation: MessageFns<LeaveOperation> = {
  encode(_: LeaveOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LeaveOperation {
    return {};
  },

  toJSON(_: LeaveOperation): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveOperation>, I>>(base?: I): LeaveOperation {
    return LeaveOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveOperation>, I>>(_: I): LeaveOperation {
    const message = createBaseLeaveOperation();
    return message;
  },
};

function createBaseMoveOperation(): MoveOperation {
  return { position: undefined };
}

export const MoveOperation: MessageFns<MoveOperation> = {
  encode(message: MoveOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveOperation {
    return { position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined };
  },

  toJSON(message: MoveOperation): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveOperation>, I>>(base?: I): MoveOperation {
    return MoveOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveOperation>, I>>(object: I): MoveOperation {
    const message = createBaseMoveOperation();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseEatPlayerOperation(): EatPlayerOperation {
  return { playerEaten: new Uint8Array(0), newRadius: 0 };
}

export const EatPlayerOperation: MessageFns<EatPlayerOperation> = {
  encode(message: EatPlayerOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerEaten.length !== 0) {
      writer.uint32(10).bytes(message.playerEaten);
    }
    if (message.newRadius !== 0) {
      writer.uint32(16).uint32(message.newRadius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EatPlayerOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEatPlayerOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerEaten = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newRadius = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EatPlayerOperation {
    return {
      playerEaten: isSet(object.playerEaten) ? bytesFromBase64(object.playerEaten) : new Uint8Array(0),
      newRadius: isSet(object.newRadius) ? globalThis.Number(object.newRadius) : 0,
    };
  },

  toJSON(message: EatPlayerOperation): unknown {
    const obj: any = {};
    if (message.playerEaten.length !== 0) {
      obj.playerEaten = base64FromBytes(message.playerEaten);
    }
    if (message.newRadius !== 0) {
      obj.newRadius = Math.round(message.newRadius);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EatPlayerOperation>, I>>(base?: I): EatPlayerOperation {
    return EatPlayerOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EatPlayerOperation>, I>>(object: I): EatPlayerOperation {
    const message = createBaseEatPlayerOperation();
    message.playerEaten = object.playerEaten ?? new Uint8Array(0);
    message.newRadius = object.newRadius ?? 0;
    return message;
  },
};

function createBaseEatFoodOperation(): EatFoodOperation {
  return { foodPosition: undefined, newRadius: 0 };
}

export const EatFoodOperation: MessageFns<EatFoodOperation> = {
  encode(message: EatFoodOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.foodPosition !== undefined) {
      Vector2D.encode(message.foodPosition, writer.uint32(10).fork()).join();
    }
    if (message.newRadius !== 0) {
      writer.uint32(16).uint32(message.newRadius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EatFoodOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEatFoodOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.foodPosition = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newRadius = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EatFoodOperation {
    return {
      foodPosition: isSet(object.foodPosition) ? Vector2D.fromJSON(object.foodPosition) : undefined,
      newRadius: isSet(object.newRadius) ? globalThis.Number(object.newRadius) : 0,
    };
  },

  toJSON(message: EatFoodOperation): unknown {
    const obj: any = {};
    if (message.foodPosition !== undefined) {
      obj.foodPosition = Vector2D.toJSON(message.foodPosition);
    }
    if (message.newRadius !== 0) {
      obj.newRadius = Math.round(message.newRadius);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EatFoodOperation>, I>>(base?: I): EatFoodOperation {
    return EatFoodOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EatFoodOperation>, I>>(object: I): EatFoodOperation {
    const message = createBaseEatFoodOperation();
    message.foodPosition = (object.foodPosition !== undefined && object.foodPosition !== null)
      ? Vector2D.fromPartial(object.foodPosition)
      : undefined;
    message.newRadius = object.newRadius ?? 0;
    return message;
  },
};

function createBasePauseOperation(): PauseOperation {
  return {};
}

export const PauseOperation: MessageFns<PauseOperation> = {
  encode(_: PauseOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PauseOperation {
    return {};
  },

  toJSON(_: PauseOperation): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PauseOperation>, I>>(base?: I): PauseOperation {
    return PauseOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PauseOperation>, I>>(_: I): PauseOperation {
    const message = createBasePauseOperation();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
