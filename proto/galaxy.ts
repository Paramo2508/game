// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.0
// source: proto/galaxy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "galaxy";

export enum EventType {
  EvUnused = 0,
  EvNewFood = 1,
  EvNewPlayer = 2,
  EvPlayerMove = 3,
  EvPlayerGrow = 4,
  EvDestroyFood = 5,
  EvDestroyPlayer = 6,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "EvUnused":
      return EventType.EvUnused;
    case 1:
    case "EvNewFood":
      return EventType.EvNewFood;
    case 2:
    case "EvNewPlayer":
      return EventType.EvNewPlayer;
    case 3:
    case "EvPlayerMove":
      return EventType.EvPlayerMove;
    case 4:
    case "EvPlayerGrow":
      return EventType.EvPlayerGrow;
    case 5:
    case "EvDestroyFood":
      return EventType.EvDestroyFood;
    case 6:
    case "EvDestroyPlayer":
      return EventType.EvDestroyPlayer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.EvUnused:
      return "EvUnused";
    case EventType.EvNewFood:
      return "EvNewFood";
    case EventType.EvNewPlayer:
      return "EvNewPlayer";
    case EventType.EvPlayerMove:
      return "EvPlayerMove";
    case EventType.EvPlayerGrow:
      return "EvPlayerGrow";
    case EventType.EvDestroyFood:
      return "EvDestroyFood";
    case EventType.EvDestroyPlayer:
      return "EvDestroyPlayer";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OperationType {
  OpUnused = 0,
  OpJoin = 1,
  OpLeave = 2,
  OpMove = 3,
  OpEatPlayer = 4,
  OpEatFood = 5,
  UNRECOGNIZED = -1,
}

export function operationTypeFromJSON(object: any): OperationType {
  switch (object) {
    case 0:
    case "OpUnused":
      return OperationType.OpUnused;
    case 1:
    case "OpJoin":
      return OperationType.OpJoin;
    case 2:
    case "OpLeave":
      return OperationType.OpLeave;
    case 3:
    case "OpMove":
      return OperationType.OpMove;
    case 4:
    case "OpEatPlayer":
      return OperationType.OpEatPlayer;
    case 5:
    case "OpEatFood":
      return OperationType.OpEatFood;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationType.UNRECOGNIZED;
  }
}

export function operationTypeToJSON(object: OperationType): string {
  switch (object) {
    case OperationType.OpUnused:
      return "OpUnused";
    case OperationType.OpJoin:
      return "OpJoin";
    case OperationType.OpLeave:
      return "OpLeave";
    case OperationType.OpMove:
      return "OpMove";
    case OperationType.OpEatPlayer:
      return "OpEatPlayer";
    case OperationType.OpEatFood:
      return "OpEatFood";
    case OperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Vector2D {
  X: number;
  Y: number;
}

export interface Event {
  eventType: EventType;
  eventData?:
    | { $case: "newPlayerEvent"; newPlayerEvent: NewPlayerEvent }
    | { $case: "newFoodEvent"; newFoodEvent: NewFoodEvent }
    | { $case: "playerMoveEvent"; playerMoveEvent: PlayerMoveEvent }
    | { $case: "playerGrowEvent"; playerGrowEvent: PlayerGrowEvent }
    | { $case: "destroyFoodEvent"; destroyFoodEvent: DestroyFoodEvent }
    | { $case: "destroyPlayerEvent"; destroyPlayerEvent: DestroyPlayerEvent }
    | undefined;
}

export interface NewPlayerEvent {
  playerID: Uint8Array;
  position: Vector2D | undefined;
  radius: number;
  color: number;
}

export interface NewFoodEvent {
  position: Vector2D | undefined;
  color: number;
}

export interface PlayerMoveEvent {
  playerID: Uint8Array;
  position: Vector2D | undefined;
}

export interface PlayerGrowEvent {
  playerID: Uint8Array;
  radius: number;
}

export interface DestroyFoodEvent {
  position: Vector2D | undefined;
}

export interface DestroyPlayerEvent {
  playerID: Uint8Array;
}

export interface Operation {
  playerID: Uint8Array;
  operationType: OperationType;
  operationData?:
    | { $case: "joinOperation"; joinOperation: JoinOperation }
    | { $case: "leaveOperation"; leaveOperation: LeaveOperation }
    | { $case: "moveOperation"; moveOperation: MoveOperation }
    | { $case: "eatPlayerOperation"; eatPlayerOperation: EatPlayerOperation }
    | { $case: "eatFoodOperation"; eatFoodOperation: EatFoodOperation }
    | undefined;
}

export interface JoinOperation {
}

export interface LeaveOperation {
}

export interface MoveOperation {
  position: Vector2D | undefined;
}

export interface EatPlayerOperation {
  playerEaten: Uint8Array;
  newRadius: number;
}

export interface EatFoodOperation {
  foodPosition: Vector2D | undefined;
  newRadius: number;
}

function createBaseVector2D(): Vector2D {
  return { X: 0, Y: 0 };
}

export const Vector2D: MessageFns<Vector2D> = {
  encode(message: Vector2D, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.X !== 0) {
      writer.uint32(8).uint32(message.X);
    }
    if (message.Y !== 0) {
      writer.uint32(16).uint32(message.Y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vector2D {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector2D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.X = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.Y = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector2D {
    return {
      X: isSet(object.X) ? globalThis.Number(object.X) : 0,
      Y: isSet(object.Y) ? globalThis.Number(object.Y) : 0,
    };
  },

  toJSON(message: Vector2D): unknown {
    const obj: any = {};
    if (message.X !== 0) {
      obj.X = Math.round(message.X);
    }
    if (message.Y !== 0) {
      obj.Y = Math.round(message.Y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector2D>, I>>(base?: I): Vector2D {
    return Vector2D.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector2D>, I>>(object: I): Vector2D {
    const message = createBaseVector2D();
    message.X = object.X ?? 0;
    message.Y = object.Y ?? 0;
    return message;
  },
};

function createBaseEvent(): Event {
  return { eventType: 0, eventData: undefined };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    switch (message.eventData?.$case) {
      case "newPlayerEvent":
        NewPlayerEvent.encode(message.eventData.newPlayerEvent, writer.uint32(18).fork()).join();
        break;
      case "newFoodEvent":
        NewFoodEvent.encode(message.eventData.newFoodEvent, writer.uint32(26).fork()).join();
        break;
      case "playerMoveEvent":
        PlayerMoveEvent.encode(message.eventData.playerMoveEvent, writer.uint32(34).fork()).join();
        break;
      case "playerGrowEvent":
        PlayerGrowEvent.encode(message.eventData.playerGrowEvent, writer.uint32(42).fork()).join();
        break;
      case "destroyFoodEvent":
        DestroyFoodEvent.encode(message.eventData.destroyFoodEvent, writer.uint32(50).fork()).join();
        break;
      case "destroyPlayerEvent":
        DestroyPlayerEvent.encode(message.eventData.destroyPlayerEvent, writer.uint32(58).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventData = {
            $case: "newPlayerEvent",
            newPlayerEvent: NewPlayerEvent.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventData = { $case: "newFoodEvent", newFoodEvent: NewFoodEvent.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventData = {
            $case: "playerMoveEvent",
            playerMoveEvent: PlayerMoveEvent.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventData = {
            $case: "playerGrowEvent",
            playerGrowEvent: PlayerGrowEvent.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eventData = {
            $case: "destroyFoodEvent",
            destroyFoodEvent: DestroyFoodEvent.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eventData = {
            $case: "destroyPlayerEvent",
            destroyPlayerEvent: DestroyPlayerEvent.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      eventType: isSet(object.eventType) ? eventTypeFromJSON(object.eventType) : 0,
      eventData: isSet(object.newPlayerEvent)
        ? { $case: "newPlayerEvent", newPlayerEvent: NewPlayerEvent.fromJSON(object.newPlayerEvent) }
        : isSet(object.newFoodEvent)
        ? { $case: "newFoodEvent", newFoodEvent: NewFoodEvent.fromJSON(object.newFoodEvent) }
        : isSet(object.playerMoveEvent)
        ? { $case: "playerMoveEvent", playerMoveEvent: PlayerMoveEvent.fromJSON(object.playerMoveEvent) }
        : isSet(object.playerGrowEvent)
        ? { $case: "playerGrowEvent", playerGrowEvent: PlayerGrowEvent.fromJSON(object.playerGrowEvent) }
        : isSet(object.destroyFoodEvent)
        ? { $case: "destroyFoodEvent", destroyFoodEvent: DestroyFoodEvent.fromJSON(object.destroyFoodEvent) }
        : isSet(object.destroyPlayerEvent)
        ? { $case: "destroyPlayerEvent", destroyPlayerEvent: DestroyPlayerEvent.fromJSON(object.destroyPlayerEvent) }
        : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = eventTypeToJSON(message.eventType);
    }
    if (message.eventData?.$case === "newPlayerEvent") {
      obj.newPlayerEvent = NewPlayerEvent.toJSON(message.eventData.newPlayerEvent);
    } else if (message.eventData?.$case === "newFoodEvent") {
      obj.newFoodEvent = NewFoodEvent.toJSON(message.eventData.newFoodEvent);
    } else if (message.eventData?.$case === "playerMoveEvent") {
      obj.playerMoveEvent = PlayerMoveEvent.toJSON(message.eventData.playerMoveEvent);
    } else if (message.eventData?.$case === "playerGrowEvent") {
      obj.playerGrowEvent = PlayerGrowEvent.toJSON(message.eventData.playerGrowEvent);
    } else if (message.eventData?.$case === "destroyFoodEvent") {
      obj.destroyFoodEvent = DestroyFoodEvent.toJSON(message.eventData.destroyFoodEvent);
    } else if (message.eventData?.$case === "destroyPlayerEvent") {
      obj.destroyPlayerEvent = DestroyPlayerEvent.toJSON(message.eventData.destroyPlayerEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.eventType = object.eventType ?? 0;
    switch (object.eventData?.$case) {
      case "newPlayerEvent": {
        if (object.eventData?.newPlayerEvent !== undefined && object.eventData?.newPlayerEvent !== null) {
          message.eventData = {
            $case: "newPlayerEvent",
            newPlayerEvent: NewPlayerEvent.fromPartial(object.eventData.newPlayerEvent),
          };
        }
        break;
      }
      case "newFoodEvent": {
        if (object.eventData?.newFoodEvent !== undefined && object.eventData?.newFoodEvent !== null) {
          message.eventData = {
            $case: "newFoodEvent",
            newFoodEvent: NewFoodEvent.fromPartial(object.eventData.newFoodEvent),
          };
        }
        break;
      }
      case "playerMoveEvent": {
        if (object.eventData?.playerMoveEvent !== undefined && object.eventData?.playerMoveEvent !== null) {
          message.eventData = {
            $case: "playerMoveEvent",
            playerMoveEvent: PlayerMoveEvent.fromPartial(object.eventData.playerMoveEvent),
          };
        }
        break;
      }
      case "playerGrowEvent": {
        if (object.eventData?.playerGrowEvent !== undefined && object.eventData?.playerGrowEvent !== null) {
          message.eventData = {
            $case: "playerGrowEvent",
            playerGrowEvent: PlayerGrowEvent.fromPartial(object.eventData.playerGrowEvent),
          };
        }
        break;
      }
      case "destroyFoodEvent": {
        if (object.eventData?.destroyFoodEvent !== undefined && object.eventData?.destroyFoodEvent !== null) {
          message.eventData = {
            $case: "destroyFoodEvent",
            destroyFoodEvent: DestroyFoodEvent.fromPartial(object.eventData.destroyFoodEvent),
          };
        }
        break;
      }
      case "destroyPlayerEvent": {
        if (object.eventData?.destroyPlayerEvent !== undefined && object.eventData?.destroyPlayerEvent !== null) {
          message.eventData = {
            $case: "destroyPlayerEvent",
            destroyPlayerEvent: DestroyPlayerEvent.fromPartial(object.eventData.destroyPlayerEvent),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseNewPlayerEvent(): NewPlayerEvent {
  return { playerID: new Uint8Array(0), position: undefined, radius: 0, color: 0 };
}

export const NewPlayerEvent: MessageFns<NewPlayerEvent> = {
  encode(message: NewPlayerEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.radius !== 0) {
      writer.uint32(24).uint32(message.radius);
    }
    if (message.color !== 0) {
      writer.uint32(32).uint32(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewPlayerEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewPlayerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.radius = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewPlayerEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
    };
  },

  toJSON(message: NewPlayerEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    if (message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewPlayerEvent>, I>>(base?: I): NewPlayerEvent {
    return NewPlayerEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewPlayerEvent>, I>>(object: I): NewPlayerEvent {
    const message = createBaseNewPlayerEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    message.radius = object.radius ?? 0;
    message.color = object.color ?? 0;
    return message;
  },
};

function createBaseNewFoodEvent(): NewFoodEvent {
  return { position: undefined, color: 0 };
}

export const NewFoodEvent: MessageFns<NewFoodEvent> = {
  encode(message: NewFoodEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.color !== 0) {
      writer.uint32(16).uint32(message.color);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewFoodEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewFoodEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.color = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewFoodEvent {
    return {
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
      color: isSet(object.color) ? globalThis.Number(object.color) : 0,
    };
  },

  toJSON(message: NewFoodEvent): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    if (message.color !== 0) {
      obj.color = Math.round(message.color);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewFoodEvent>, I>>(base?: I): NewFoodEvent {
    return NewFoodEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewFoodEvent>, I>>(object: I): NewFoodEvent {
    const message = createBaseNewFoodEvent();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    message.color = object.color ?? 0;
    return message;
  },
};

function createBasePlayerMoveEvent(): PlayerMoveEvent {
  return { playerID: new Uint8Array(0), position: undefined };
}

export const PlayerMoveEvent: MessageFns<PlayerMoveEvent> = {
  encode(message: PlayerMoveEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerMoveEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerMoveEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerMoveEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: PlayerMoveEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerMoveEvent>, I>>(base?: I): PlayerMoveEvent {
    return PlayerMoveEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerMoveEvent>, I>>(object: I): PlayerMoveEvent {
    const message = createBasePlayerMoveEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBasePlayerGrowEvent(): PlayerGrowEvent {
  return { playerID: new Uint8Array(0), radius: 0 };
}

export const PlayerGrowEvent: MessageFns<PlayerGrowEvent> = {
  encode(message: PlayerGrowEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.radius !== 0) {
      writer.uint32(16).uint32(message.radius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerGrowEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerGrowEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.radius = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerGrowEvent {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
    };
  },

  toJSON(message: PlayerGrowEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.radius !== 0) {
      obj.radius = Math.round(message.radius);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerGrowEvent>, I>>(base?: I): PlayerGrowEvent {
    return PlayerGrowEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerGrowEvent>, I>>(object: I): PlayerGrowEvent {
    const message = createBasePlayerGrowEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.radius = object.radius ?? 0;
    return message;
  },
};

function createBaseDestroyFoodEvent(): DestroyFoodEvent {
  return { position: undefined };
}

export const DestroyFoodEvent: MessageFns<DestroyFoodEvent> = {
  encode(message: DestroyFoodEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyFoodEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyFoodEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyFoodEvent {
    return { position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined };
  },

  toJSON(message: DestroyFoodEvent): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyFoodEvent>, I>>(base?: I): DestroyFoodEvent {
    return DestroyFoodEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyFoodEvent>, I>>(object: I): DestroyFoodEvent {
    const message = createBaseDestroyFoodEvent();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseDestroyPlayerEvent(): DestroyPlayerEvent {
  return { playerID: new Uint8Array(0) };
}

export const DestroyPlayerEvent: MessageFns<DestroyPlayerEvent> = {
  encode(message: DestroyPlayerEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyPlayerEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyPlayerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyPlayerEvent {
    return { playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0) };
  },

  toJSON(message: DestroyPlayerEvent): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyPlayerEvent>, I>>(base?: I): DestroyPlayerEvent {
    return DestroyPlayerEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyPlayerEvent>, I>>(object: I): DestroyPlayerEvent {
    const message = createBaseDestroyPlayerEvent();
    message.playerID = object.playerID ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOperation(): Operation {
  return { playerID: new Uint8Array(0), operationType: 0, operationData: undefined };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerID.length !== 0) {
      writer.uint32(10).bytes(message.playerID);
    }
    if (message.operationType !== 0) {
      writer.uint32(16).int32(message.operationType);
    }
    switch (message.operationData?.$case) {
      case "joinOperation":
        JoinOperation.encode(message.operationData.joinOperation, writer.uint32(26).fork()).join();
        break;
      case "leaveOperation":
        LeaveOperation.encode(message.operationData.leaveOperation, writer.uint32(34).fork()).join();
        break;
      case "moveOperation":
        MoveOperation.encode(message.operationData.moveOperation, writer.uint32(42).fork()).join();
        break;
      case "eatPlayerOperation":
        EatPlayerOperation.encode(message.operationData.eatPlayerOperation, writer.uint32(50).fork()).join();
        break;
      case "eatFoodOperation":
        EatFoodOperation.encode(message.operationData.eatFoodOperation, writer.uint32(58).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerID = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operationData = {
            $case: "joinOperation",
            joinOperation: JoinOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operationData = {
            $case: "leaveOperation",
            leaveOperation: LeaveOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.operationData = {
            $case: "moveOperation",
            moveOperation: MoveOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.operationData = {
            $case: "eatPlayerOperation",
            eatPlayerOperation: EatPlayerOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operationData = {
            $case: "eatFoodOperation",
            eatFoodOperation: EatFoodOperation.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      playerID: isSet(object.playerID) ? bytesFromBase64(object.playerID) : new Uint8Array(0),
      operationType: isSet(object.operationType) ? operationTypeFromJSON(object.operationType) : 0,
      operationData: isSet(object.joinOperation)
        ? { $case: "joinOperation", joinOperation: JoinOperation.fromJSON(object.joinOperation) }
        : isSet(object.leaveOperation)
        ? { $case: "leaveOperation", leaveOperation: LeaveOperation.fromJSON(object.leaveOperation) }
        : isSet(object.moveOperation)
        ? { $case: "moveOperation", moveOperation: MoveOperation.fromJSON(object.moveOperation) }
        : isSet(object.eatPlayerOperation)
        ? { $case: "eatPlayerOperation", eatPlayerOperation: EatPlayerOperation.fromJSON(object.eatPlayerOperation) }
        : isSet(object.eatFoodOperation)
        ? { $case: "eatFoodOperation", eatFoodOperation: EatFoodOperation.fromJSON(object.eatFoodOperation) }
        : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.playerID.length !== 0) {
      obj.playerID = base64FromBytes(message.playerID);
    }
    if (message.operationType !== 0) {
      obj.operationType = operationTypeToJSON(message.operationType);
    }
    if (message.operationData?.$case === "joinOperation") {
      obj.joinOperation = JoinOperation.toJSON(message.operationData.joinOperation);
    } else if (message.operationData?.$case === "leaveOperation") {
      obj.leaveOperation = LeaveOperation.toJSON(message.operationData.leaveOperation);
    } else if (message.operationData?.$case === "moveOperation") {
      obj.moveOperation = MoveOperation.toJSON(message.operationData.moveOperation);
    } else if (message.operationData?.$case === "eatPlayerOperation") {
      obj.eatPlayerOperation = EatPlayerOperation.toJSON(message.operationData.eatPlayerOperation);
    } else if (message.operationData?.$case === "eatFoodOperation") {
      obj.eatFoodOperation = EatFoodOperation.toJSON(message.operationData.eatFoodOperation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(object: I): Operation {
    const message = createBaseOperation();
    message.playerID = object.playerID ?? new Uint8Array(0);
    message.operationType = object.operationType ?? 0;
    switch (object.operationData?.$case) {
      case "joinOperation": {
        if (object.operationData?.joinOperation !== undefined && object.operationData?.joinOperation !== null) {
          message.operationData = {
            $case: "joinOperation",
            joinOperation: JoinOperation.fromPartial(object.operationData.joinOperation),
          };
        }
        break;
      }
      case "leaveOperation": {
        if (object.operationData?.leaveOperation !== undefined && object.operationData?.leaveOperation !== null) {
          message.operationData = {
            $case: "leaveOperation",
            leaveOperation: LeaveOperation.fromPartial(object.operationData.leaveOperation),
          };
        }
        break;
      }
      case "moveOperation": {
        if (object.operationData?.moveOperation !== undefined && object.operationData?.moveOperation !== null) {
          message.operationData = {
            $case: "moveOperation",
            moveOperation: MoveOperation.fromPartial(object.operationData.moveOperation),
          };
        }
        break;
      }
      case "eatPlayerOperation": {
        if (
          object.operationData?.eatPlayerOperation !== undefined && object.operationData?.eatPlayerOperation !== null
        ) {
          message.operationData = {
            $case: "eatPlayerOperation",
            eatPlayerOperation: EatPlayerOperation.fromPartial(object.operationData.eatPlayerOperation),
          };
        }
        break;
      }
      case "eatFoodOperation": {
        if (object.operationData?.eatFoodOperation !== undefined && object.operationData?.eatFoodOperation !== null) {
          message.operationData = {
            $case: "eatFoodOperation",
            eatFoodOperation: EatFoodOperation.fromPartial(object.operationData.eatFoodOperation),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseJoinOperation(): JoinOperation {
  return {};
}

export const JoinOperation: MessageFns<JoinOperation> = {
  encode(_: JoinOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): JoinOperation {
    return {};
  },

  toJSON(_: JoinOperation): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinOperation>, I>>(base?: I): JoinOperation {
    return JoinOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinOperation>, I>>(_: I): JoinOperation {
    const message = createBaseJoinOperation();
    return message;
  },
};

function createBaseLeaveOperation(): LeaveOperation {
  return {};
}

export const LeaveOperation: MessageFns<LeaveOperation> = {
  encode(_: LeaveOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LeaveOperation {
    return {};
  },

  toJSON(_: LeaveOperation): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveOperation>, I>>(base?: I): LeaveOperation {
    return LeaveOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveOperation>, I>>(_: I): LeaveOperation {
    const message = createBaseLeaveOperation();
    return message;
  },
};

function createBaseMoveOperation(): MoveOperation {
  return { position: undefined };
}

export const MoveOperation: MessageFns<MoveOperation> = {
  encode(message: MoveOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Vector2D.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Vector2D.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveOperation {
    return { position: isSet(object.position) ? Vector2D.fromJSON(object.position) : undefined };
  },

  toJSON(message: MoveOperation): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2D.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveOperation>, I>>(base?: I): MoveOperation {
    return MoveOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveOperation>, I>>(object: I): MoveOperation {
    const message = createBaseMoveOperation();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2D.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseEatPlayerOperation(): EatPlayerOperation {
  return { playerEaten: new Uint8Array(0), newRadius: 0 };
}

export const EatPlayerOperation: MessageFns<EatPlayerOperation> = {
  encode(message: EatPlayerOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerEaten.length !== 0) {
      writer.uint32(10).bytes(message.playerEaten);
    }
    if (message.newRadius !== 0) {
      writer.uint32(16).uint32(message.newRadius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EatPlayerOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEatPlayerOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerEaten = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newRadius = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EatPlayerOperation {
    return {
      playerEaten: isSet(object.playerEaten) ? bytesFromBase64(object.playerEaten) : new Uint8Array(0),
      newRadius: isSet(object.newRadius) ? globalThis.Number(object.newRadius) : 0,
    };
  },

  toJSON(message: EatPlayerOperation): unknown {
    const obj: any = {};
    if (message.playerEaten.length !== 0) {
      obj.playerEaten = base64FromBytes(message.playerEaten);
    }
    if (message.newRadius !== 0) {
      obj.newRadius = Math.round(message.newRadius);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EatPlayerOperation>, I>>(base?: I): EatPlayerOperation {
    return EatPlayerOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EatPlayerOperation>, I>>(object: I): EatPlayerOperation {
    const message = createBaseEatPlayerOperation();
    message.playerEaten = object.playerEaten ?? new Uint8Array(0);
    message.newRadius = object.newRadius ?? 0;
    return message;
  },
};

function createBaseEatFoodOperation(): EatFoodOperation {
  return { foodPosition: undefined, newRadius: 0 };
}

export const EatFoodOperation: MessageFns<EatFoodOperation> = {
  encode(message: EatFoodOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.foodPosition !== undefined) {
      Vector2D.encode(message.foodPosition, writer.uint32(10).fork()).join();
    }
    if (message.newRadius !== 0) {
      writer.uint32(16).uint32(message.newRadius);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EatFoodOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEatFoodOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.foodPosition = Vector2D.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newRadius = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EatFoodOperation {
    return {
      foodPosition: isSet(object.foodPosition) ? Vector2D.fromJSON(object.foodPosition) : undefined,
      newRadius: isSet(object.newRadius) ? globalThis.Number(object.newRadius) : 0,
    };
  },

  toJSON(message: EatFoodOperation): unknown {
    const obj: any = {};
    if (message.foodPosition !== undefined) {
      obj.foodPosition = Vector2D.toJSON(message.foodPosition);
    }
    if (message.newRadius !== 0) {
      obj.newRadius = Math.round(message.newRadius);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EatFoodOperation>, I>>(base?: I): EatFoodOperation {
    return EatFoodOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EatFoodOperation>, I>>(object: I): EatFoodOperation {
    const message = createBaseEatFoodOperation();
    message.foodPosition = (object.foodPosition !== undefined && object.foodPosition !== null)
      ? Vector2D.fromPartial(object.foodPosition)
      : undefined;
    message.newRadius = object.newRadius ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
